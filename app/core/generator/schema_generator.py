import json
from typing import Dict, List
from venv import logger

from app.core.llm.llm_client import LlmClient
from app.core.prompt import schema
from app.core.schema.edge import Edge
from app.core.schema.node import Node
from app.core.schema.schema_graph import SchemaGraph

class SchemaGenerator():
    """Schema generator based on LLM"""
    def __init__(self, llm_client:LlmClient):
        self._llm_client = llm_client
    
    def _calc_node_range(self, complexity: int) -> tuple:
        """Calculate node count range based on complexity level"""
        return {
            1: (3, 5),
            2: (5, 8),
            3: (8, 12),
            4: (12, 18),
            5: (18, 25)
        }.get(complexity, (5, 10))
    
    def _calc_relationship_range(self, complexity: int) -> tuple:
        """Calculate relationship count range based on complexity level"""
        return {
            1: (2, 4),
            2: (4, 7),
            3: (7, 12),
            4: (12, 20),
            5: (20, 35)
        }.get(complexity, (4, 8))

    def generate_des(self,domain:str, subdomain:str) -> str:
        llm_client = self._llm_client

        GENERATER_DES_PROMPT = schema.Generate_des_prompt
        GENERATER_DES_INSTRUCTION = schema.Generate_des_instruction_template.format(
            domain=domain,
            subdomain=subdomain
        )

        messages = [
            {"role": "system","content": GENERATER_DES_PROMPT,},
            {"role": "user", "content": GENERATER_DES_INSTRUCTION},
        ]
        response = llm_client.call_with_messages(messages)
        return response
    
    def generate_schema(self, domain: str, subdomain: str, complexity_level: int) -> SchemaGraph:
        
        node_range = self._calc_node_range(complexity_level)
        rel_range = self._calc_relationship_range(complexity_level)
        
        schema_description = self.generate_des(domain, subdomain)  # schema description generated by LLM

        GENERATER_SCHEMA_PROMPT = schema.PROMPT
        GENERATER_SCHEMA_INSTRUCTION = schema.INSTRUCTION.format(
            schema_description=schema_description,
            domain=domain,
            subdomain=subdomain,
            example_json=schema.EXAMPLE_JSON,
            min_nodes=node_range[0],
            max_nodes=node_range[1],
            min_rels=rel_range[0],
            max_rels=rel_range[1]
        )

        logger.debug(f"Generated prompt:\n{GENERATER_SCHEMA_INSTRUCTION}")

        messages = [
            {"role": "system","content": GENERATER_SCHEMA_PROMPT,},
            {"role": "user", "content": GENERATER_SCHEMA_INSTRUCTION},
        ]

        response = self._llm_client.call_with_messages(messages)
        
        logger.debug(f"LLM raw response:\n{response}")

        schema_json = self._parse_llm_response(response)
        
        # return SchemaGraph instance
        return self._build_schema_graph(domain, schema_json)
    
    def _parse_llm_response(self, response: str) -> list:
        """Extract and parse JSON data from LLM response"""
        try:
            # Attempt direct parsing of the entire response
            return json.loads(response)
        except json.JSONDecodeError:
            try:
                # Attempt to extract JSON from code block
                start_idx = response.find('[')
                end_idx = response.rfind(']') + 1
                json_str = response[start_idx:end_idx]
                return json.loads(json_str)
            except (ValueError, IndexError, json.JSONDecodeError) as e:
                logger.error(f"Failed to parse LLM response: {e}\nResponse content: {response[:500]}...")
                raise SchemaParseError("Unable to parse Schema data returned by LLM") from e

    def _build_schema_graph(self, domain: str, schema_data: List[Dict]) -> SchemaGraph:
        """Convert LLM-generated JSON data into SchemaGraph instance"""
        schema_graph = SchemaGraph(db_id=domain)
        
        # Process all nodes
        node_map = {}
        for item in schema_data:
            if item["type"] == "VERTEX":
                node = Node(
                    label=item["label"],
                    properties=item["properties"],
                    # Add Primary attribute
                    primary=item["primary"]
                )
                schema_graph.add_node(node)
                node_map[item["label"]] = node
        
        # process all edges
        for item in schema_data:
            if item["type"] == "EDGE":
                # Extract source and target node labels
                src_dst_list = []
                for constraint in item.get("constraints", []):
                    if len(constraint) == 2:
                        src_label, dst_label = constraint
                        src_dst_list.append([src_label, dst_label])
                
                edge = Edge(
                    label=item["label"],
                    src_dst_list=src_dst_list,
                    properties=item.get("properties", [])
                )
                schema_graph.add_edge(edge)
        
        return schema_graph

class SchemaParseError(Exception):
    """Custom exception for Schema parsing errors"""
    pass
